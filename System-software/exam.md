# 1.1 Редактор vi. Редактирование командной строки при установке set –o vi.

## Редактор vi. Основные команды

- i - перейти в режим ввода с текущей позиции

- a - перейти в режим ввода после курсора

- I - переместиться в начало строки и перейти в режим ввода

- А - переместиться в конец строки и перейти в режим ввода

- o - перейти в режим ввода с новой строки под курсором

- O - перейти в режим ввода с новой строки над курсором

- v - режим выделения

- y - скопировать в буфер

- p - вставить из буфера

- 0 — в начало текущей строки

- $ — в конец текущей строки

- w — на слово вправо

- b — на слово влево

- W — до пробела вправо

- B — до пробела влево

- } — абзац вниз

- { — абзац вверх

- gg — перейти в начало файла

- G — перейти в конец файла

- <number>G — перейти на конкретную строку <number>

- /<text> — перейти к <text>

- ?<text> — то же самое, но искать назад

- n — повторить поиск

- N — повторить поиск назад

- :q - выход из текущее окна

- :wq - записать изменения и выйти

- :q! - выйти без сохранения изменений

- `-о` - ключ, разбивает окно редактора на 2 по горизонтали

- `-О` - ключ, разбивает окно редактора на 2 по вертикали

- CTRL-w w - быстрое переключение на следующее окно

## Редактирование командной строки при установке `set –o vi`.

эта командаа позволяет использовать в командной строке операции vi. (переходы в начало строки, на слово вправо/влево, удалить слово)

`Esc` - переход в командный режим

# 1.2. Редактор emacs. Редактирование командной строки при установке set –o emacs

## Редактор emacs. Основные команды.

- ctrl-p - перемещение на одну строку вверх

- ctri-n - перемещение на одну строку вниз

- ctrl-f - перемещение на однин символ вперед

- ctrl-b - перемещение на однин символ назад

- ctrl-a - начало строки

- ctrl-e - конец строки

- alt-f - вперед на одно слово

- alt-b - назад на одно слово

- ctrl-d - удалить следующий символ

- alt-d - удалить след. слово

- ctrl-x ctrl-c - выйти

## Редактирование командной строки при установке `set –o emacs`.

эта командаа позволяет использовать в командной строке операции emacs. (переходы в начало строки, на слово вправо/влево, удалить слово)

`Esc` - переход в командный режим

# 1.3. Структура системы встроенной электронной помощи и команда man.

Справочные страницы поделены на 8 стандартных разделов и один дополнительный:

1. Прикладные программы и команды оболочки
2. Системные вызовы ядра (функции языка Си)
3. Библиотечные вызовы (функции различных библиотек, установленных в систему)
4. Специальные файлы (находящиеся обычно в каталоге /dev)
5. Форматы файлов и соглашения
6. Игры
7. Различные описания, соглашения и прочее
8. Команды администрирования системы, которые обычно запускаются от имени суперпользователя
9. Ядро операционной системы 

В команде man номер раздела в команде man указывается вторым аргументом. Если номер опущен, то поиск по всем разделам по порядку.

# 1.4 Интерпретатор ksh. Файлы инициализации, переменные окружения и их экспортирование.

это язык команд и программирования, выполняющий команды, считанные из терминала или файла)))

скрипт инициаллизации для ksh расположен в `.profile` и `.kshrc` --  `.profile` выполняется при первом входе в систему, `.kshrc` выполняется при каждом запуске интерпретатора

переменные окружения хранятся в `.profile`

задание переменной: `name="val"`. В этом случае переменная сохранится до закрытия терминала, чтобы сохранть ее, нужно воспользоваться командой `export`.
Имена	переменных	могут	содержать	буквы,	цифры	и	подчеркивание (_)	

# 1.5 Служебные символы (метасимволы) интерпретатора ksh. Экранирование служебных символов.

метасимволы: `<`, `>`, `|`, `;`, `&`, `(`, `)`, `#` (комментарий, кроме #!), `$` (подстановка), `~`, `{`, `}`, `*`, `?`, `[`, `

экранирование метасимволов: `\`, `"`, `'`

# 1.6 Потоки ввода/вывода, фильтры, конвейеры, перенаправление потоков ввода/вывода.

## Cтандартные потоки ввода-вывода

Стандартные потоки ввода-вывода — потоки процесса, имеющие номер (дескриптор), зарезервированный для выполнения «стандартных» функций.

### Стандартный ввод

Поток номер 0 (stdin) зарезервирован для чтения команд пользователя или входных данных. Для изменения цели этого потока используется <

### Стандартный вывод

Поток номер 1 (stdout) зарезервирован для вывода данных. Для перенаправления этого потока используется >.

### Стандартный вывод ошибок

Поток номер 2 (stderr) зарезервирован для вывода диагностических и отладочных сообщений. Для перенаправления этого потока используется констукция 2>

## Фильтры

__Команды фильтры__ - могут использоваться в конвейерах: считывают ввод команды, преобразовывают ввод, а затем записывают выходные данные. Команды-фильтры дают возможность сортировать, просматривать и отбирать часть выходной информации других команд.

## Конвейер

__Конвейер__ - некоторое множество процессов, для которых выполнено следующее перенаправление ввода-вывода: то, что выводит на поток стандартного вывода предыдущий процесс, попадает в поток стандартного ввода следующего процесса. Запуск конвейера реализован с помощью системного вызова `pipe()`.


## Перенаправление потоков: `>` `<` `>>` `<<` `>&`

`команда1 > файл1` — выполняет команду1, помещая стандартный вывод в файл1

`команда1 < файл1` - выполняет команду1, используя в качестве источника ввода файл1

`команда1 2> файл1` - выполняет команду1, направляя стандартный поток ошибок в файл1

`команда1 >&2` - выполняет команду1, направляя стандартный ввода в стандартный поток ошибок

`команда1 >> файл1` — выполняет команду1, помещая стандартный вывод в файл1. Разница с > в том, что >> не перезаписывает файл, а добавляет данные в конец.

# 1.7 Команды работы с файлами и каталогами, права доступа и их изменение.

## chmod

chmod — программа для изменения прав доступа к файлам и каталогам. 

изменение прав: 

1. символьный вид: 

владелец u;

группа g;

остальные o;

2. числовой вид:

chmod никогда не изменяет права на символьные ссылки. но изменяет права доступа связанного с ней файла.

Помимо стандартных разрешений 'rwx', команда chmod осуществляет также управление битами __SGID, SUID и T__. Установленные атрибуты SUID или SGID позволяют запускать файл на выполнение с правами владельца файла или группы соответственно: SUID — 4000 («rwsrwxrwx»), а SGID — 2000 («rwxrwsrwx»), Т - 1000

__sticky bit или restricted deletion flag (t-бит)__ используется только с каталогами. Когда t-бит для каталога не установлен, файл в данном каталоге может удалить (переименовать) любой пользователь, имеющий доступ на запись к данному каталогу. Устанавливая t-бит на каталог, мы меняем это правило таким образом, что удалить (переименовать) файл может только владелец этого файла.

## umask

маска для создания пользовательских файлов

## setfacl 

гибкая работа с правами доступа. Можно устанавливать права для отдельных пользователей и групп. Эти права хранятся в файле acl

# 1.8 Команда find и применение метасимволов при подстановке имен файлов.

__find__  - ищет файлы в иерархии каталогов, удовлетворяющие определенному
условию. 

`-name` поиск файлов с определенным именем

`-type` поиск файлов с определенным типом

`-user` поиск файлов с определенным пользователем

`-group` поиск файлов с определенной группой

`-perm` поиск файлов с определенными правами доступа

find поддерживает такие метасимволы: `*`, `?`, `[`, `]`. Ключ `-regex` позволяет совершать поиск по регуляркам

# 1.9 Порядок выполнения команд, операторы ||, &&, (), {}.

`find . -empty -exec ls {} \; ` - ищет пустые файлы, имена подставляет в {}.

`cd aaa && ls` ничего не сделает, если каталога AAA нет

`cd AAA || ls` в любом случае сделает ls

круглые скобки для группировки этого безобразия

# 1.10 Регулярные выражения и семейство команд grep.

 метасимволы в регулярках 
 
- `[ ]` - набор символов

- `\` - символ экранирования

- `/` - граница 

- `^` - начало строки

- `$` - конец строки

- `.` - один символ

- `|` - "или"

- `?` - ноль или один символ 

- `*` - ноль или более символов

- `+` - один или более симвлов

- `( )` - группа

- `{n, m}` - количество раз

специальные символы: 

- `\d` - цифра

- `\D` - не цифра

- `\s` - пробел

- `\S` - не пробел

- `\w` - буква

- `\W` - не буква

- `\b` - граница слова

- `\B` - не граница слова

- `\G` - предыдущий успешный поиск

- `\n`, `\t` - перенос строки, таб

В каждой утилите свой набор метасимволов. Например, в egrep (grep -E) выражение рассматривается как расширенное: т.е.  позволяет использовать такие метасимволы, как `+` (одно и более повторений), `?` (0 и более повторений), `|` (логическое или)

# 1.11 Потоковый редактор awk. Шаблоны и процедуры. Работа с полями и записями.

awk  -  команда контекстного поиска и преобразования текста.
 
Программа состоит из операторов (правил), имеющих вид: шаблон {действие}
  
## Шаблон: 

регулярное выражение (обрамляются `/` `/`), по которому осуществляется поиск строк для последующей обработки. Так же можно задавать диапазон шаблонов 

`шаблон1, шаблон2 { действие }`

В этом случае действие выполняется для каждой строки, начиная со строки, удовлетворяющей шаблону1, и заканчивая строкой, удовлетворяющей шаблону2.

## Ключевые слова в программе: 

BEGIN,   break,   log,       END,     close,   next,       FILENAME, continue,number,       FS (разделитель полей),      exit,    print,       NF (число записей),      exp,     printf,       NR (число входных записей, прочитанных к данному моменту),      for,     split,       OFS,     getline, sprintf,       ORS,     if,      sqrt,       OFMT,    in,      string,       RS (разделитель записей),    index,   substr,     int,     while,   length
       
## Специальные переменные:

`$0` - текущая запись

`$1`, `$2`, ... -- первое, второе поле соответстенно

# 1.12 Операторы и встроенные переменные awk. Передача переменных из ksh в awk.

## Встроенные переменные

- NR - Порядковый номер текущей записи.
  
- NF - Число полей в текущей записи.

- FS -	Входной разделитель полей, по умолчанию равен пробелу/табуляции.
 
 - RS - Входной разделитель записей, по умолчанию равен символу перевода строки.
  
 - $i - i-е поле текущей записи.
 
 - $0 -	Текущая входная запись целиком.
  
 - OFS -	Выходной разделитель полей, по умолчанию равен пробелу.
  
 - ORS -	Выходной разделитель записей, по умолчанию равен символу перевода строки.
  
  - OFMT - 	Формат для вывода на печать чисел, используется оператором print; по умолчанию равен %.6g.
  
  - FILENAME - 	Имя файла, из которого в данный момент производится ввод. Это удобно, поскольку обычно awk-программы имеют вид
  
  ## Операторы
  
  `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`, `+`, `-`, `*`, `/`, `%`, `()` (группировка), `<`, `>`, `<=`, `>=`, `!=`, `&&`, `||`, `!`, `~`, `!~`
  
 ## Передача переменных из ksh в awk.
 
  ```awk
  awk 'BEGIN {print "'"$HOME"'"}'
  ```
  
  вот так работает)
  
  # 1.13 Потоковый редактор sed. Команды p, a, i, c, d, s, w, r, q, l. Примеры.
  
  `p` - печать в stdout
  
  ```
  sed -n 5,10p datebook
  печать с 5 по 10 строку
  ```
  
  `a` - вывести текст за обрабатываемой строкой
  
 ```
  sed '/^north /a\
--->THE NORTH SALES DISTRICT HAS MOVED<---' datafile
```

`i`  - так-же как a, но текст выводится перед выводом буфера.
`
`c` - так-же как a, но текст выводится вместо выводом буфера.

`d` - удаляет содержимое буфера.

```
sed 1,3d datebook
удаляет строки с 1 по 3
```

`s` - команда замены

```
sed 's/^.*Jose.*$/JOSE HAS RETIRED/' datebook
заменяет найденную строку
```

`w FILENAME` - Записывает буфер в FILENAME

```
sed -n '/north/w newfile' datafile
В файл newfile запишутся все строки, содержащие north.
```

`r FILENAME` - Эта команда читает файл FILENAME в конце текущего цикла (или перед чтение следующей строки), и выводит его содержимое в выходной поток.

`q` - Прерывание работы скрипта. Буфер выводится в выходной поток. 

`l` - Вывод буфера в переносимой форме: непечатные символы(а так-же «\») выводится в Си-стиле (тремя восьмеричными цифрами, и перед ними добавляется «\») Длинные строки разрезаются, при резке в конец новых строк добавляется «\», Конец каждой строки помечается символом «$».

# 1.14 Сортировка файлов. Команда sort.

основные ключи: 

-b, --ignore-leading-blanks:
игнорировать начальные пропуски

-d, --dictionary-order: 
рассматривать только пропуски, буквы и цифры

-f, --ignore-case:
игнорировать регистр букв

-i, --ignore-nonprinting:
рассматривать только печатные знаки

-n, --numeric-sort:
сравнивать численные значения строк

-h, --human-numeric-sort:
сравнивать численные значения с учетом сокращения степени (2K, 1G)

-r, --reverse:
обратить результаты сравнения

-u, --unique:
с -c, проверять порядок строго; без -c, выводить только первое среди нескольких равных

-c, --check:
проверять, сортированы ли входные файлы; не сортировать

-k, --key=Поз1[,Поз2]:
начинать ключ в Поз1 и завершать на Поз2 (отсчет от 1)

-o, --output=ФАЙЛ:
выводить в ФАЙЛ, а не на стандартный вывод

-t, --field-separator=РАЗДЕЛИТЕЛЬ:
использовать при поиске ключевых полей РАЗДЕЛИТЕЛЬ, а не переход от непробельных знаков к пробельным

-m:
использовать оперативную память в качестве буфера

# 1.15 Проверка уникальности строк и отдельных полей. Команда uniq.

утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в отсортированном файле. Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода.

основные ключи: 

-u: 
Выводить только те строки, которые не повторяются на входе.

-d: 
Выводить только те строки, которые повторяются на входе.

-c: 
Перед каждой строкой выводить число повторений этой строки на входе и один пробел.

-i:
Сравнивать строки без учёта регистра.

-s: число_символов
Определяет количество символов, начиная с начала строки, игнорируемых при сравнении. Все остальные символы сравниваются. Символы нумеруются начиная с единицы.

-w число символов:
Определяет количество символов, начиная с начала строки, участвующих в сравнении. Все остальные символы игнорируются.

-f число_полей:
Игнорировать при сравнении первые число_полей полей каждой строки ввода. Полем является строка непробельных символов, отделённая от соседних полей пробельными символами. Поля нумеруются начиная с единицы.

# 1.16 Объединение файлов. Команда join.

команда, объединяющая строки двух упорядоченных текстовых файлов на основе наличия общего поля

join принимает на входе два текстовых файла и некоторое число аргументов. Если не передаются никакие аргументы командной строки, то данная команда ищет пары строк в двух файлах, обладающие совпадающим первым полем, и выводит строку, состоящую из первого поля и содержимого обеих строк.

```
файл 1:
строка1 текст1
строка2 текст2

файл 2: 
строка1 текст11
строка3 текст3

join без аргументов:
строка1 текст1 текст11
```

основные ключи: 

-a номер_файла:	Дополнительно вывести непарные строки файла 1 или 2

-e строка:	Пустые поля заменять строкой

-j [номер_файла] поле: Выполнить сравнение по полю файла

-o список_полей:	Выходные строки составлять согласно спискам, состоящим из элементов вида номер_файла.поле

-t символ_разделитель: Задание разделителей полей

# 1.17 Вставка текста. Команда paste.

paste — команда, предназначенная для вставки колонок. Программа рассматривает файлы, как вертикальные колонки, соединяет их и выводит в стандартный поток вывода.

основные ключи:

-s — меняет положение строк со столбцами;

-d разделитель — меняет разделитель на указанный (по умолчанию TAB).

```
файл 1:
строка1 текст1
строка2 текст2

файл 2: 
строка1 текст11
строка3 текст3

paste f1 f2
строка1 текст1  строка1 текст11
строка2 текст2  строка3 текст3
```

# 1.18 Команды tee, tr, wc, cut, split, diff, comm, sleep, pwd, set, type, file, du, df, kill, ps, eval.

## tee

tee - читает данные из стандартного потока ввода, а затем пишет их в
стандартный поток вывода и файлы.

-a: добавить данные в конец файла, а не перезаписывать его

-i: игнорировать ошибки

## tr

tr - выполнить символьное преобразование путём подстановки или удаления
символов.

-d: удаляет все символы, которые перечислены в наборе без преобразования

-s: заменяет последовательность повторяющихся символов в наборе на один
символ

## wc

wc - выводит количество строк, слов, байт в каждом файле.

-c: выводит только количество байт

-m: выводит только количество символов

-l: выводит только количество строк

-w: выводит только количество слов

## cut

cut - выводить выбранные столбцы каждого заданного файла.

-d: символ использовать символ вместо символа табуляции

-f: список выводит только столбцы, перечисленные в списке

## split

split - скопировать файл и разбить его на отдельные файлы заданной длины

-l, -: число количество строк в новых файлах

-b: количество байт

## diff

diff - искать различия между двумя файлами.

-b: игнорировать изменения в количестве пробелов, табуляций и т. п.

-w: игнорировать пробелы и табуляции и т. п. при сравнении строк

-i: игнорировать изменения в регистре символов

-r: производить рекурсивное сравнение всех найденных подкаталогов

-s: вывести отчет, если файлы идентичны

## comm

comm —  читает файл1 и файл2, которые должны быть предварительно лексически отсортированы, и генерирует вывод, состоящий из трёх колонок текста: строки, найденные только в файле файл1; строки, найденные только в файле файл2; и строки, общие для обоих файлов.

-1: 
Подавить вывод первой колонки.

-2:
Подавить вывод второй колонки.

-3:
Подавить вывод третьей колонки.

-i:
Игнорировать регистр

## sleep

sleep — утилита, выполняющая задержку на указанное время (например, при исполнении shell-сценария)

sleep 5: 
даёт указание скрипту приостановить работу на 5 секунд

sleep 5h: 
даёт указание скрипту приостановить работу на 5 часов

## pwd

pwd - выводит абсолютный путь текущего рабочего каталога.

## set

set - клманда для подключения и отключения опций

### флаги для ksh:

-a: Все последующие переменные, автоматически экспортируются

-b: Заставляет оболочку асинхронно уведомлять пользователя о завершении фоновых заданий.

-C: препядствует перезаписи существующих файлов оператором перенаправления `>`. Перенаправлять потоки можно при помощи `>|`

-f: Отключает генерацию имени файла.

-m: Фоновые задания выполняются в отдельной группе процессов, и после их завершения печатается cообщение о завершении. 

-n: Читает команды и проверяет их на наличие синтаксических ошибок, но не выполняет их.

-p: использует privileged, вместо $HOME/.profile

-х: Печатает команды и их аргументы по мере их выполнения.

+o, -o: добавляет или удаляет опцию соответственно

### опции:

`allexport` - то же, что ключ -а (се последующие переменные, автоматически экспортируются)

`bgnice` - Все фоновые задания выполняются с более низким приоритетом. Это режим "по умолчанию".

`ignoreeof` - ввод данных не завершается при end-of-file. должна быть использована команда выхода.

`markdirs` - все имена каталогов имеют в конце `/`

`monitor` - то же, что и -m (Фоновые задания выполняются в отдельной группе процессов, и после их завершения печатается cообщение о завершении.)

`noclobber` - то же, что и -С (препядствует перезаписи существующих файлов оператором перенаправления `>`. Перенаправлять потоки можно при помощи `>|`)

`noexec` - то же, что и -n (Читает команды и проверяет их на наличие синтаксических ошибок, но не выполняет их)

`nolog` - не сохраняет историю

`notify` - == -b (Заставляет оболочку асинхронно уведомлять пользователя о завершении фоновых заданий.)

`vi` - переводит в режим редактора vi при работе с командной строкой при нажатии esc

`privileged` - == -p (использует privileged, вместо $HOME/.profile)

`noglob` - то же, что и -f (Отключает генерацию имени файла.)

`xtrace` - == -х (Печатает команды и их аргументы по мере их выполнения.)

## type

type - определяет, как аргументы интерпретируются командной оболочкой,
если бы они были поданы в качестве команды.

## file

file - определяет с помощью серии тестов тип файлов.

-b: краткий режим (не добавляет имя файла)

-d: печатает полученную информацию в stderr

## du

du - программа для оценки занимаемого файлового пространства. 

–b:  выводит информацию в байтах(а не в килобайтах).

–c:  выводит итоговую информацию об использовании дисковой памяти.

–k:  выводит информацию в килобайтах(по умолчанию).

–s:  выводит итоговую информацию об использовании дискового пространства без информации о каталогах.

-h:  вывести инофрмацию в человекочитаемом виде.

## df

df — утилита, показывает список всех файловых систем по именам устройств, сообщает их размер, занятое и свободное пространство и точки монтирования.

-h, --human-readable: 
Отобразит размер в человеко-читаемом формате, добавив названия единиц

-a, --all:
Включает в список файловых систем те, которые имеют размер в 0 блоков

-k:
Используется для отображения размеров блоками по 1 килобайту, вместо установленных по умолчанию блоков в 512 байт.

-i, --inodes: 
Вместо информации о блоках выдаётся информация об использовании inode'ов в файловой системе.

## kill

kill - Завершает процесс текущего пользователя на основе его PID. Утилита kill
отправляет сигнал одному или нескольким процессам. Обычно этот сигнал
завершает процессы.

-l: выводит список имен сигналов

-s: указать посылаемый сигнал. Сигнал должен быть указан по имени либо
по номеру

### сигналы

|Сигнал | Номер| Действие по умолчанию | Описание |
|-------|------|-----------------------|----------|
| SIGHUP | 1 | Завершение | Закрытие терминала |
| SIGINT | 2 | Завершение | Сигнал прерывания (Ctrl-C) с терминала |
| SIGTSTP | 20 | Остановка процесса | Сигнал остановки с терминала (Ctrl-Z). |
| SIGTERM | 15 | Завершение | Сигнал завершения (сигнал по умолчанию для утилиты kill) |
| SIGSTOP | 23 | Остановка процесса | Остановка выполнения процесса |
| SIGKILL | 9 | Завершение | Безусловное завершение |
| SIGCONT | 25 | Продолжить выполнение | Продолжить выполнение ранее остановленного процесса |

## ps

ps - выводит информацию о состоянии процессов, запущенных на локальной
системе. Если использовать список процессов, ps выводит отчет только о тех
процессах,
которые указаны в списке

-А: все процессы

-a: все наиболее часто вызываемые процессы: кроме главных системных
процессов
сеанса и процессов, не связанных с конкретным терминалом

-d: все процессы, кроме главных системных процессов сеанса

-f: расширение информации

-x: процессы, отсоединенные от терминала

## eval

eval - принимает строку в качестве аргумента и оценивает ее так, как если бы вы набрали эту строку в командной строке. Т.е. команда Eval пригодится, когда в переменной хранится команда unix или linux, и вы хотите выполнить эту команду, хранящуюся в строке.

# 1.19 Выполнение команд в фоновом режиме. Команды crontab, at, &, nohup, nice, priocntl.

## crontab

crontab - демон-планировщик задач, использующийся для периодического
выполнения заданий в определённое время. Регулярные действия описываются
инструкциями, помещенными в файлы crontab и в специальные директории. Каждый
пользователь системы имеет свой файл заданий crontab, в котором описано, в какое
время и какие программы запускать от имени этого пользователя. Для
редактирования файла crontab используется специальная одноименная программа
crontab, позволяющая не прерывать процесс cron на время редактирования. Для
редактирования файла crontab вашего пользователя используется команда «crontab
-e».

Таблица crontab состоит из 6 колонок, разделяемых пробелами или табуляторами.
Первые пять колонок задают время выполнения (Минута, Час, День, Месяц, День
недели), в них может находиться число, список чисел, разделённых запятыми,
диапазон чисел, разделенных дефисом, символы '*' или '/'. В системных файлах
crontab после полей времени указывается пользователь, от которого запускается
команда. Все остальные символы в строке интерпретируются как выполняемая
команда с её параметрами.

Кроме того, для некоторых часто используемых наборов были придуманы
переменные:

•@reboot — при загрузке, только один раз;

•@yearly, @annually — раз год;

•@monthly — раз в месяц;

•@weekly — раз в неделю;

некоторые ключи:

-r: удалить регулярные действия текущего пользователя из этого каталога

-l: выдать на стандартный вывод файл с регулярными действиями
текущего пользователя

## at

at - предназначена для управления службой atd (atd предназначена для выполнения
команд в заданное время). В отличие от службы crond, служба atd выполняет каждую
команду лишь раз и не предназначена для выполнения команд через заданные
промежутки времени и позволяет вам планировать выполнение команды один раз в
заданное время без редактирования файла конфигурации.

некоторые ключи:

-q: используется для указания очереди

-m: позволяет отправить пользователю сообщение по электронной почте

-f: позволяет прочитать команды из файла, а не со стандартного ввода

## &

& - при добавлении в конце команды, запуск её происходит в фоновом режиме.
Исключения составляют интерактивные команды, требующие взаимодействия с
пользователем.

## nohup

nohup - запуск команды, которая продолжает свою работу после вашего выхода из
системы. Иными словами, nohup заставляет процесс игнорировать сигнал SIGHUP. В
зависимости от настройки локальной оболочки она может прекращать работу
фоновых процессов.

## nice

nice - запускает программу с измененным приоритетом для планировщика задач.
Если смещение не указано, то приоритет команды увеличивается на 10.

Привилегированный пользователь (root) может указать отрицательное смещение.

Команда nice может смещать приоритет в диапазоне от −20 (наивысший приоритет)
до 20 (низший приоритет).

-n: используется для изменения приоритета

## priocntl

priocntl - выдает или устанавливает параметры планировщика (scheduling
parameters) для указанного процесса или процессов. Процессы разбиваются на
разные классы, для каждого из которых применяются свои правила планирования. В
настоящее время поддерживаются следующие классы: процессы реального времени,
процессы с разделением времени и интерактивные процессы.

-d: выдает параметры планировщика для заданного набора процессов

-e: выполняет указанную команду с заданным классом и параметрами
планировщика для всех процессов

-с: задает класс, который надо установить. (Допускаются аргументы: RT -
процессы реального времени (real-time), TS - процессы с разделением
времени (time-sharing) и IA - интерактивные процессы (inter-active).) Если
указанный класс еще не сконфигурирован, он конфигурируется
автоматически.

# 1.20 Создание и монтирование файловой системы. Команды mkfs, newfs, mount, umount, fsck.

## mkfs

mkfs - создаёт новую файловую систему Linux  

`mkfs [ -V ] [ -t fstype ] [ fs-options ] filesys [ blocks ]  `

В качестве аргумента filesys для файловой системы может выступать или название устройства (например, /dev/hda1, /dev/sdb2) или точка монтирования (например, /, /usr, /home). Аргументом blocks указывается количество блоков, которые выделяются для использования этой файловой системой.

-V:
Подробно информирует происходящее, включая все выполняемые специфические команды файловой системы.

-t fstype:
Указывает тип создаваемой файловой системы. По умолчанию: ext2.

fs-options: 
Передаёт модулю создания специфической файловой системы параметры в виде списка.

-c: 
Перед созданием файловой системы проверяет наличие сбойных блоков на устройстве.

-l filename:
Считывает список сбойных блоков из указанного файла filename.

## newfs

Newfs используется для инициализации и очистки файловых систем перед первым использованием. Перед запуском newfs или mount_mfs диск должен быть помечен как disklabel.

-b размер_блока: Указывает размер блока в файловой системе в байтах. Он должен быть степенью числа 2. По умолчанию размер 8192 байта. Наименьший возможный размер 4096 байтов.

-f размер_фрагмента: Указывает размер фрагмента файловой системы в байтах. Значение должно лежать в пределах от размер_блока/8 до размер_блока и быть степенью числа 2. По умолчанию используется размер 1024 байта.

-i количество_байт_на_элемент_индексной_таблицы: Указывает плотность индексных записей в файловой системе. По умолчанию создается по записи на каждые 4 * размер_фрагмента байт пространства данных. 

-m свободное_место %: Процент свободного места, резервируемого на файловой системе, т.е. порог минимального свободного пространства.

-o способ_оптимизации

## mount

mount — утилита командной строки в UNIX-подобных операционных системах. Применяется для монтирования файловых систем.

```
mount /dev/cdrom /mnt/cdrom

Устройство /dev/cdrom монтируется в каталог /mnt/cdrom, если он существует. 
```

-a: Монтирует все файловые системы указанного типа, описания которых содержатся в файле /etc/fstab.

-t vfstype:
Аргумент следующий за -t указывает тип файловой системы. 

-r:
Монтирует файловую систему в режиме "только для чтения". 

-w:
Монтирует файловую систему в режиме "чтения/запись".

## unmount

Для размонтирования достаточно указать точку монтирования или имя устройства.

`umount /dev/cdrom`

## fsck 

fsck  — команда UNIX, которая проверяет и устраняет ошибки в файловой системе.

Код, возвращаемый fsck, является суммой следующих условий:

0 — нет ошибок

1 — ошибки файловой системы исправлены

2 — необходима перезагрузка системы

4 — ошибки файловой системы не исправлены

8 — в процессе проверки произошли ошибки

16 — неверное использование команды либо синтаксическая ошибка

32 — fsck была прервана пользователем

128 — ошибка разделяемых объектов

-a: автоматическое иправление ошибок

-n: без исправления ошибок

-с: изменение интервала проверки (По-умолчанию fsck выполняется каждые 30 загрузок или 180 дней)


# Регулярные выражения. 

## 1. Представление символов.

`\n` Символ перевода строки

`\e` Символ Escape

`\a` Сигнал (при «выводе» раздается звуковой сигнал). код 033 (в восьмеричной системе)

`\f` Перевод формата. код 014 (в восьмеричной системе).

`\r` Символ возврата каретки

`\t` Символ горизонтальной табуляции. код 011 (в восьмеричной системе).

`\v` Символ вертикальной табуляции.  код 013 (в восьмеричной системе).

`\< или \b` Позиция в начале слова. \b граница слова, т. е. позиция между словом и пробелом или переводом строки. 

`/> или \b` Позиция в конце слова. \b граница слова, т. е. позиция между словом и пробелом или переводом строки.

`\d` Цифра. Эквивалентно [0-9]

`\D` Любой символ, кроме цифр. Все, что не относится к \d Эквивалентно [^0-9]

`\w` Цифра, буква (латинский алфавит) или знак подчеркивания. Эквивалентно [0-9a-zA-Z_]. Частая конструкция для поиска слов \w+

`\W` Любой символ, кроме цифр, букв (латинский алфавит) и знака подчеркивания. Все, что не относится к \w. Эквивалентно
[^0-9a-zA-Z_]

`\s` соответствует любому «пробельному» символу (пробел, табуляция, новая строка, перевод формата и т. д.).

`\S` Любой символ, кроме пробельных. Все, что не относится к \s

